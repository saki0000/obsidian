---
source:
  - https://medium.com/androiddevelopers/coroutines-on-android-part-ii-getting-started-3bff117176dd
---
# コルーチンの追跡問題
[[コルーチン]]自体はタスクが終わったかどうかを追跡できない。
しかし、手動で追跡するコードを書くとしても、コルーチンはたくさんある場合難しい。
コルーチンの追跡を失ってしまった場合、メモリーやCPU, diskなどを浪費してしまう。
## 解決策
kotlinでは、[[structured concurrency]]に従い、[[CoroutineScope]]内でコルーチンを開始する。
## structured concurrencyで出来ること
1. 必要がなくなった作業をキャンセルする
2. 実行中の作業を追跡する
3. コルーチンが失敗した時にエラーを合図する
## コルーチンの開始
コルーチンを開始するには２つの方法がある
1. __launch builder__ : 起動して忘れる新しいコルーチンを開始する
	- 呼び出し元に結果を返さない
2. __async builder__ : 新しい子ルーチンを開始する
	- awaitと呼ばれるsuspend関数で結果を返す
```ad-note
 ほとんどの場合は、`launch`で始めることが多い。
 理由は、通常の関数では`await`を呼び出すことができないから。
```

```
scope.launch {  
	// This block starts a new coroutine  
	// "in" the scope.  
	//  
	// It can call suspend functions  
	fetchDocs()  
}
```
```ad-warning

`launch`と`async`を比べると例外の扱い方が大きな違い。`async`は最終的に`await`から結果を受け取るので、通常例外を投げない。そのため、`async`を使う際は例外が漏れている可能性に気を付ける
```

## Androidのコルーチンのライフタイム
```ad-faq
`CotoutineScope`でコルーチンを開始したとして、いつコルーチンをキャンセルすればいい？
```

Androidにおいて、多くの場合は、`CotoutineScope`をユーザー画面に関連づける。そうすることで、`Activities`や`Fragments`に関して余計な作業をする必要がなくなる。

Androidのアーキテクチャとコルーチンを関連づける場合、コルーチンはviewModelで開始することが望ましい。
その際、[[viewModelScope]]を使ってコルーチンを開始させる
## Keep track of work
```ad-faq
コルーチン無いで２つのネットワークリクエストを同時に実行したい場合、さらに多くの子ルーチンを開始するには？
```

#### suspend関数を`coroutineScope`や`supervisorScope`のビルダーを使うことでより多くのコルーチンを作ることができる。

```ad-faq
新しいコルーチンをいろんなところで作成することはwork Leaksに繋がる。
作業を追跡するにはどうしたらいいか？
```
#### structured concurrencyでは、suspend関数がリターンしたことは、作業が終わったことを保証する
```
suspend fun fetchTwoDocs() {  
	coroutineScope {  
		launch { fetchDoc(1) }  
		async { fetchDoc(2) }  
	}  
}
```
上記では、lauchで開始される[[コルーチン]]とasyncで開始される[[コルーチン]]がある。
launchはcallerに結果を返さず、asyncはcallerに結果を返す。
#### `coroutineScope`と`supervisorScope`はsuspend関数から安全にコルーチンを開始することができる
Kotlinでは、`coroutineScope`ビルダーはビルダー内の全てのコルーチンが完了するまで一時停止する。
先ほどの例では、`fetchDoc(1)`と`fetchDoc(2)`が完了したら`fetchTwoDocs`が値を返すようになっている。
![[CoroutineScope.excalidraw]]
#### `coroutineScope`と`supervisorScope`はビルダー内のコルーチンが完了するのを待機する
`coroutineScope`と`supervisorScope`を使うことでコルーチンを安全に始められる。これによってwork leaksをしなくなる。
また、`coroutineScope`は子スコープを作り、`coroutineScope`がキャンセルされたら子スコープのコルーチンも全て同時にキャンセルされる。
```ad-note
#### coroutineScopeとsupervisorScopeの違い
coroutineScope: 一つのコルーチンがキャンセルされると全てキャンセルされる
supervisorScope: 一つのコルーチンがキャンセルされても他のコルーチンは続行する
```
### コルーチンが失敗した時のエラーのシグナル
コルーチンは通常の関数と同じように例外を投げることでエラーが合図される。
- suspend関数は再開した時にcallerに例外が再スローされる。
- suspend関数も例外を扱うのにtry/catchを使える
- エラーハンドリングを抽象化できる
```ad-warning
しかし、コルーチンでエラーを見失う状況がある
```
```
val unrelatedScope = MainScope()

// example of a lost error  
suspend fun lostError() {  
    // async without structured concurrency  
    unrelatedScope.async {  
        throw InAsyncNoOneCanHearYou("except")  
    }  
}
```
```ad-faq
Q:関係ないスコープってどういうこと？
A:[[unstructured concurrency]]
```
上記のコードは関係のないコルーチンスコープでコルーチンを開始しており、structured concurrencyではない。
`async`は例外を投げているところで`await`が呼ばれると思っている。しかし、関係ないコルーチンスコープでは例外を感知できず、例外は永遠に補完されたままになる。
#### structured concurrencyはコルーチンがエラーの際にcallerかスコープが築くことを保証する
```
suspend fun foundError() {  
	coroutineScope {  
		async {  
			throw StructuredConcurrencyWill("throw")  
		}  
	}  
}
```
`coroutineScope`は全ての子スコープにあるコルーチンが終わるのを待つことができる。
また、コルーチンが失敗したことにも気づける。
つまり`coroutineScope`で開始したコルーチンが失敗したことをcallerに投げることができる。
```ad-warning
`supervisorScope`では例外を投げることができない
```